#
# A Git Parser for ZSH
# written in C
#

export CGIT_DIR=${0:A:h}

function update_git_info()
{
    setopt LOCAL_OPTIONS
    local ahead_and_behind
    local ahead_format
    local ahead_formatted
    local behind_format
    local behind_formatted
    local branch_format
    local branch_formatted
    local clean_formatted
    local commit_format
    local commit_formatted
    local dirty_format
    local dirty_formatted
    local -A info_formats
    local info_format
    local modified_format
    local modified_formatted
    #local position
    #local position_format
    #local position_formatted
    local remote_format
    local remote_formatted
    # local unindexed_format
    # local unindexed_formatted
    local unmerged_format
    local unmerged_formatted
    local untracked_format
    local untracked_formatted

    unset FORMAT_GIT_INFO
    unset CURRENT_GIT_INFO

    if ! $(git rev-parse --is-inside-work-tree 2> /dev/null); then
        return 1
    fi

    # # Return if git-info is disabled.
    # if ! is-true "${$(git config --bool prompt.showinfo):-true}"; then
    #     return 1
    # fi

    typeset -gA FORMAT_GIT_INFO
    local gitparser="/Users/robertgz/Development/go/bin/go-gitparser"
    # local gitparser="/tmp/bin/cgit"

    GIT_INFO=`${gitparser} 2>/dev/null`

    CURRENT_GIT_INFO=("${(@s:,:)GIT_INFO}")

    local commit=$CURRENT_GIT_INFO[1]
    local branch=$CURRENT_GIT_INFO[2]
    local remote=$CURRENT_GIT_INFO[3]
    local ahead=$CURRENT_GIT_INFO[4]
    local behind=$CURRENT_GIT_INFO[5]
    local untracked=$CURRENT_GIT_INFO[6]
    local added=$CURRENT_GIT_INFO[7]
    local modified=$CURRENT_GIT_INFO[8]
    local deleted=$CURRENT_GIT_INFO[9]
    local deleted=$CURRENT_GIT_INFO[10]
    local renamed=$CURRENT_GIT_INFO[11]
    local copied=$CURRENT_GIT_INFO[12]

    # Format commit
    zstyle -s ':git:info:commit' format 'commit_format'
    if [[ -n "$commit" && -n "$commit_format" ]]; then
        zformat -f commit_formatted "$commit_format" "c:$commit"
    fi

    # Format branch
    zstyle -s ':git:info:branch' format 'branch_format'
    if [[ -n "$branch" && -n "$branch_format" ]]; then
        zformat -f branch_formatted "$branch_format" "b:$branch"
    fi

    # Format remote.
    zstyle -s ':git:info:remote' format 'remote_format'
    if [[ -n "$remote" && -n "$remote_format" ]]; then
        zformat -f remote_formatted "$remote_format" "r:$remote"
    fi

    # Format ahead and behind
    zstyle -s ':git:info:ahead' format 'ahead_format'
    zstyle -s ':git:info:behind' format 'behind_format'
    # Format ahead.
    if [[ -n "$ahead_format" ]]; then
      if (( ahead > 0 )) ; then
        zformat -f ahead_formatted "$ahead_format" "A:$ahead"
      fi
    fi
    # Format behind.
    if [[ -n "$behind_format" ]]; then
      if (( behind > 0 )) ; then
        zformat -f behind_formatted "$behind_format" "B:$behind"
      fi
    fi

    if ! zstyle -t ':git:info' verbose; then
        # indexed
        echo "not supported"
        return 1
    else
        # unmerged
        if (( unmerged > 0 )) ; then
            zstyle -s ':git:info:unmerged' format 'unmerged_format'
            zformat -f unmerged_formatted "$unmerged_format" "U:$unmerged"
        fi

        # modified
        if (( modified > 0 )) ; then
            zstyle -s ':git:info:modified' format 'modified_format'
            zformat -f modified_formatted "$modified_format" "m:$modified"
        fi

        # untracked
        if (( untracked > 0 )) ; then
            zstyle -s ':git:info:untracked' format 'untracked_format'
            zformat -f untracked_formatted "$untracked_format" "u:$untracked"
        fi
    fi

    # Format dirty and clean
    if (( added > 0 || deleted > 0 || renamed > 0 || copied > 0 || renamed > 0 )) ; then
        zstyle -s ':git:info:dirty' format 'dirty_format'
        zformat -f dirty_formatted "$dirty_format" "D:$dirty"
    else
        zstyle -s ':git:info:clean' format 'clean_formatted'
    fi

    # Format info.
    zstyle -a ':git:info:keys' format 'info_formats'
    for info_format in ${(k)info_formats}; do
        zformat -f REPLY "$info_formats[$info_format]" \
            "c:$commit_formatted" \
            "b:$branch_formatted" \
            "r:$remote_formatted" \
            "A:$ahead_formatted" \
            "B:$behind_formatted" \
            "D:$dirty_formatted" \
            "C:$clean_formatted" \
            "U:$unmerged_formatted" \
            "m:$modified_formatted" \
            "u:$untracked_formatted"
        FORMAT_GIT_INFO[$info_format]="$REPLY"
    done

            # "M:$matches_formatted" \
            # "S:$staged_formatted" \

    unset REPLY
    return 0
}

update_git_info "$@"