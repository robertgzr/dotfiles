#!/bin/env zsh

# Provide a minimal prompt interface

# Sets up: pwd
# takes 'short' as argument

_prompt_minimal_start_time=$SECONDS

# prints shell context if not than local machine
function prompt_update_context {
    local user=`whoami`
    prompt_context=""

    # prints nothing if whoami returns $USER -> local connection
    if [[ "$user" != "$USER" || -n "$SSH_CONNECTION" ]]; then
         prompt_context=" $user@%m "
    else
        prompt_context=""
    fi
}

# prints the current directory (short/long format)
function prompt_dir() {
    if [[ $1 = short ]]; then
        # shortend path behaviour
        local pwd="${PWD/#$HOME/~}"

        if [[ "$pwd" == (#m)[/~] ]]; then
            prompt_pwd="$MATCH"
            unset MATCH
        else
            prompt_pwd="$FG[002]$FX[no-bold]$FX[italic]${${${${(@j:/:M)${(@s:/:)pwd}##.#?}:h}%/}//\%/%%}/${${pwd:t}//\%/%%}"
        fi
    else
        # default behaviour
        prompt_pwd=" %~%<< "
    fi
}

# prints the time since login to shell instance
function prompt_paradox_print_elapsed_time {
  local end_time=$(( SECONDS - _prompt_minimal_start_time ))
  local hours minutes seconds remainder

  if (( end_time >= 3600 )); then
    hours=$(( end_time / 3600 ))
    remainder=$(( end_time % 3600 ))
    minutes=$(( remainder / 60 ))
    seconds=$(( remainder % 60 ))
    print -P "%B%F{red}>>> elapsed time ${hours}h${minutes}m${seconds}s%b"
  elif (( end_time >= 60 )); then
    minutes=$(( end_time / 60 ))
    seconds=$(( end_time % 60 ))
    print -P "%B%F{yellow}>>> elapsed time ${minutes}m${seconds}s%b"
  elif (( end_time > 10 )); then
    print -P "%B%F{green}>>> elapsed time ${end_time}s%b"
  fi
}

# ==== Prompt constructor functions

# executes prior to any command
function prompt_precmd {
    prompt_update_context
    prompt_dir short

    autoload -Uz update_git_info
    if (( $+functions[update_git_info] )); then
        update_git_info
    fi

    PROMPT='$prompt_context$FG[002]$prompt_pwd%{%f%}$FX[reset] $FG[255]> '

    if [[ -n "$FORMAT_GIT_INFO" ]]; then
        RPROMPT='$FORMAT_GIT_INFO[status]'
    fi

    # Calc elapsed time
    prompt_paradox_print_elapsed_time
}

# executes prior to any command execution
function prompt_preexec {
    _prompt_minimal_elapsed_time="$SECONDS"
}

function prompt_minimal {
    setopt LOCAL_OPTIONS
    unsetopt XTRACE KSH_ARRAYS
    autoload -Uz add-zsh-hook

    zstyle ':git:info' verbose 'yes'

    zstyle ':git:info:commit' format "%c"
    zstyle ':git:info:branch' format "$FG[004]$FX[bold]%b$FX[reset]"

    zstyle ':git:info:ahead' format "$BG[130]$FX[bold]↑ %A$FX[reset]"
    zstyle ':git:info:behind' format "$BG[089]$FX[bold]↓ %B$FX[reset]"

    zstyle ':git:info:clean' format " $FG[007]✔$FX[reset]"
    zstyle ':git:info:dirty' format " $FG[001]✗$FX[reset]"
    zstyle ':git:info:unmerged' format "═"
    zstyle ':git:info:modified' format " $FG[093]✱$FX[reset]"
    zstyle ':git:info:untracked' format " ?"

    zstyle ':git:info:keys' format \
        'status' "$FG[245]$FX[bold] %b$FG[240]@$FX[reset]%c %A%B%m%U%u%C%D" \
        'short' "$FG[245] %b%C%D"

    add-zsh-hook preexec prompt_preexec
    add-zsh-hook precmd prompt_precmd
}

prompt_minimal "$@"